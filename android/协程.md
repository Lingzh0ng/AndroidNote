# 协程

## 概览

Kotlin 协程（Coroutines）是一种用于异步编程的轻量级解决方案。它提供了一种在代码中以顺序、清晰的方式处理异步任务的方法，而无需显式地使用回调函数或者繁琐的线程管理， Kotlin 协程提供了一种更加简洁、易读的方式来处理异步任务，避免了传统回调地狱的问题，并且能够更好地与现有的同步代码整合

## 概念和特点

### 挂起函数

> 使用关键字‘suspend’修饰的函数，协程使用挂起函数来暂停执行而不阻塞线程。协程在遇到suspend函数时，会暂停执行，将协程挂起，并在某个条件满足时继续执行  

```kotlin
suspend fun doSomething() {
    // 挂起函数的实现
} 
```

>  挂起函数的实现原理涉及到 Kotlin 协程的底层机制和编译器的支持。在解释挂起函数的实现原理之前，我们需要了解两个核心概念：协程上下文（Coroutine Context）和协程调度器（Coroutine Dispatcher）。

* 协程上下文： 协程上下文是包含有关协程的一些运行时信息的对象。这些信息包括协程的状态、调度器、异常处理器等。协程上下文通过 coroutineContext 属性访问。

* 协程调度器： 协程调度器定义了协程运行的上下文，包括线程池或其他执行环境。调度器负责确定协程在哪个线程或执行环境中运行。
  
  >  现在，让我们来看挂起函数的实现原理：

* 编译器转换： 编译器会对包含挂起函数的协程进行转换，将代码分割为多个部分，其中包括可能导致协程挂起的点。这个转换过程称为“挂起点插入”（Suspension Point Insertion）。

* 状态机： 编译器使用状态机来追踪协程的状态。每个挂起点都被转换为状态机的一个状态。当协程遇到挂起点时，它会将自己的状态保存到状态机中，并挂起。当异步操作完成时，协程会被恢复，状态机负责将协程恢复到正确的状态。

* 协程上下文的保存和恢复： 在协程被挂起时，其上下文的信息会被保存起来，以便在协程恢复时能够还原到正确的状态。这涉及到保存变量、调度器信息等。

* Continuation： 协程的执行被封装在一个称为 Continuation 的对象中。Continuation 保存了协程的状态，并负责在协程恢复时继续执行。当协程被挂起时，Continuation 会被传递给异步操作，以便在操作完成后能够恢复协程的执行。

>  总体来说，挂起函数的实现依赖于编译器的转换和生成的状态机。这些机制使得在协程中能够更自然地编写异步代码，而不需要手动管理线程或回调函数。这种方式让开发者可以更直观地表达异步逻辑，提高了代码的可读性和维护性。

### 调度器

> 调度器定义了协程运行的上下文，包括线程池或其他执行环境。常见的调度器包括 Dispatchers.IO、Dispatchers.Default、Dispatchers.Main 等

* Dispatchers.Default：
  
  > 适用于 CPU 密集型的工作，例如计算或密集的算法处理。
  >  使用共享的线程池，线程数量受限于 CPU 的核心数。

* Dispatchers.IO：
  
  > 适用于 I/O 操作，例如文件操作、数据库访问、网络请求等。
  > 使用共享的线程池，可以执行大量的阻塞操作。

* Dispatchers.Main：
  
  > 适用于与 UI 相关的操作，例如更新 UI 元素。
  > 在 Android 中，它会使用 UI 线程（主线程）执行。

* Dispatchers.Unconfined：
  
  > 不指定特定的线程，协程在挂起后可能在任何线程上恢复执行。
  > 一般用于不受限的、不依赖特定线程上下文的协程。

> 这些调度器是 CoroutineDispatcher 类型的对象，实现了协程调度的具体逻辑。当协程
> 被启动时，可以通过协程构建器的 dispatcher 参数来指定使用哪个调度器执行协程。

### 作用域

> 协程通常在一个特定的作用域中运行，作用域定义了协程的生命周期。常见的作用域包括 GlobalScope、CoroutineScope 、ViewModelScope 、LifecycleScope等

* GlobalScope
  
  > GlobalScope 是一个顶层的协程作用域，它的生命周期与整个应用程序的生命周期相同。在 Android 中，使用 GlobalScope 启动的协程会在整个应用程序的生命周期内执行。然而，建议尽量避免在 Android 应用中使用 GlobalScope，因为它的生命周期过长可能导致资源泄漏。

* CoroutineScope
  
  > 创建自定义的协程作用域，例如通过继承 CoroutineScope 接口并提供相应的上下文和生命周期。这使得你可以创建与特定组件或任务相关的协程作用域。

* ViewModelScope
  
  > ViewModelScope 是专门为与 ViewModel 关联的协程而设计的作用域。它的生命周期与关联的 ViewModel 的生命周期相同。使用 viewModelScope 可以确保协程在 ViewModel 存在时运行，在 ViewModel 被清理时取消协程。

* LifecycleScope
  
  > LifecycleScope 是与 Android Architecture Components 中的 Lifecycle 组件关联的作用域。通过使用 lifecycleScope，可以确保协程在指定的 Lifecycle 的活动状态内运行，而在生命周期结束时自动取消。
  
  ### 异步

* 通过 async 构建器可以进行异步操作，并通过 await 获取异步操作的结果
  
  ```kotlin
  val result: Deferred<Int> = CoroutineScope(Dispatchers.Default).async {
    // 异步操作的代码
    return@async 42
  }
  val value: Int = result.await()
  ```

* 协程通过挂起函数（suspend 函数）来处理异步操作。在协程中，当执行到挂起函数时，协程会暂停执行，而不会阻塞线程，等待异步操作完成。这样可以使得代码看起来像是同步执行的，而不需要回调地狱或显式的线程管理
  
  ### 协程上下文
  
  > 在 Kotlin 协程中，协程上下文（CoroutineContext）是一个包含有关协程执行的各种信息的对象。协程上下文定义了协程的运行时环境，包括调度器、异常处理器、协程名称等。它是由多个元素组成的，其中最常见的是调度器（CoroutineDispatcher）。
  > 以下是一些常见的协程上下文元素：

* 调度器（Dispatcher）：
  定义了协程在哪个线程或线程池中执行。例如，Dispatchers.Default 表示在默认的共享线程池中执行，而 Dispatchers.IO 表示在 I/O 操作相关的线程池中执行。

* Job：
  表示协程的执行单元，用于取消协程。协程的生命周期与其关联的 Job 相关联。例如，Job() 创建一个新的顶层作业，而 viewModelScope 或 lifecycleScope 会创建与 Android 生命周期关联的作业。

* 异常处理器（CoroutineExceptionHandler）：
  定义了协程内部异常的处理方式。可以通过 CoroutineExceptionHandler 来指定处理协程内抛出的异常的逻辑。

* 协程命名（CoroutineName）：
  为协程指定一个名称，便于调试和日志记录。

* 父协程（CoroutineScope）：
  将协程链接到父协程，使得父协程的取消能够传播到其所有子协程。通常通过 coroutineScope 或 supervisorScope 创建。

* 这些上下文元素可以通过 + 操作符进行组合，形成一个完整的协程上下文。例如，Dispatchers.Main + Job() 表示一个在主线程执行的协程，并关联一个作业（用于取消）
  
  ### 协程构建器
  
  otlin 协程提供了几种构建器（coroutine builders）来启动协程，每个构建器都用于不同的使用场景。以下是一些常见的协程构建器：

* launch：

用于启动一个不返回结果的协程。适用于执行一些异步任务，不需要等待结果的场景。
示例：

```kotlin
GlobalScope.launch {
    // 协程的代码
}
```

* async：

用于启动一个返回 Deferred 对象的协程，可以通过该对象获取协程的执行结果。

```kotlin
val deferredResult = GlobalScope.async {
    // 协程的代码
    "Result"
}
val result = deferredResult.await()
```

* runBlocking：

用于启动一个阻塞当前线程的协程，通常用于测试和 main 函数中。

```kotlin
runBlocking {
    // 协程的代码
}
```

* withContext：

用于在指定的调度器上执行协程体，并返回执行结果。常用于切换协程的执行线程。

```kotlin
val result = withContext(Dispatchers.IO) {
    // 在 IO 调度器中执行的协程体
    "Result"
}
```

* coroutineScope：

用于创建一个新的协程作用域，该作用域内启动的所有协程都与该作用域的生命周期关联。

```kotlin
coroutineScope {
    // 协程的代码
}
```

* supervisorScope：

与 coroutineScope 类似，但是子协程的失败不会传播给父协程，父协程不会被取消。

```kotlin
supervisorScope {
    // 协程的代码
}
```

* 这些构建器提供了不同的协程启动方式，适应于各种场景。选择合适的构建器取决于你的需求，例如是否需要等待协程执行结果、是否需要取消等。协程的构建器是使用协程的起点，从而启动异步任务并创建协程的执行上下文。

## 疑问

### 协程挂起为什么不会阻塞线程

> 协程的挂起不会阻塞线程的主要原因是，协程是一种轻量级的并发模型，它可以在一个线程中执行多个协程，而不需要为每个协程分配一个新的线程。这种轻量级并发模型与传统的线程模型不同，因此挂起协程并不会导致线程阻塞。

> 以下是一些解释为什么协程的挂起不会阻塞线程的关键点：

* 挂起是非阻塞的： 当协程遇到挂起点（例如，调用了一个挂起函数）时，它会暂停执行，但不会阻塞线程。协程的挂起是一种协作式的、非阻塞的行为，它是通过协程调度器的管理来实现的。

* 协程调度器： 协程调度器负责决定协程在哪个线程上运行。当一个协程被挂起后，调度器可以选择在同一线程上运行其他协程，或者将协程移动到另一个线程上。这种调度机制使得线程能够灵活地执行多个协程，而不会因为一个协程的挂起而被阻塞。

* 线程池和异步操作： 在异步操作中，例如网络请求、文件读写等，协程的挂起点并不等同于线程的阻塞点。当协程遇到异步操作时，协程可能被挂起，但线程可以继续执行其他任务，而不必等待异步操作完成。

* 总的来说，协程的非阻塞挂起机制允许在一个线程中执行多个协程，而无需为每个协程分配一个新的线程。这提高了并发性能和资源利用率，并使得异步编程更加高效和可管理。协程通过协作式的挂起和调度机制，使得异步操作能够以更加灵活和高效的方式进行。

### 协程join()、yield()
